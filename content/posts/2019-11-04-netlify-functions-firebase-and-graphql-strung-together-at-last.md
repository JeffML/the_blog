---
template: post
title: 'Netlify Functions, Firebase, and GraphQL: working together at last!'
slug: /posts/netlify-firebase
draft: true
date: 2019-11-05T01:39:17.922Z
description: >-
  It wasn't easy, but I finally have a Netlify hosted React app talking to a
  lambda GraphQL server fronting a Firebase database. Whew!
category: Technical
tags:
  - Firebase
  - Netlify
  - lambda
  - GraphQL
  - Apollo
---
In a [previous post](https://www.freecodecamp.org/news/you-cant-get-there-from-here-how-netlify-lambda-and-firebase-led-me-to-a-serverless-dead-end/) I confessed defeat in attempting to get a lambda GraphQL server to connect a Firestore instance.  A short time later I found a different Node package to achieve what I couldn't before: it allowed the Firebase credentials file to be passed in as a JSON dependency.

# But...

It turns out there are more to dependencies in Netlify Functions than are readily apparent. In fact, there are several ways to deploy a lambda function to Netlify:

## zip-it-and-ship-it

This is a utility that works a lot like webpack: for each function it creates an archive file along with all its dependencies.  Like webpack, it only pulls in dependencies that are actually required by the function. For instance:

![](/media/screenshot-2019-11-05-at-3.45.48-pm.png "Source folder for lambda functions")

This has two lambda functions, plus a node_module folder for the module dependencies needed by the lambda functions. To use zip-it-and-ship-it, you write a simple JavaScript program to be called in the package.json's build scripts. That program defines the input folder (functions) and the output folder (say, functions_build).  Once run, you get several .zip files that can be deployed and run on Netlify. Those zip files contain a the function code as well as a node_modules folder that has only those dependencies needed by each function:

![](/media/screenshot-2019-11-05-at-3.52.56-pm.png "The function build output")

The zip-it-and-ship-it mechanism is also involved in the following two processes:

## netlify-lambda

You can read about netlify-lambda here. Under the covers, it's using zip-it-and-ship-it.

## continuous deployment

The continuous deployment option is available if you're using one of the supported repositories, like github. Once you push changes to the repo, Netlify is notified and will run your build processes. This could involve zip-it-and-ship-it or netlify-lambda. You can also bypass both of those tools and Netlify will attempt to build the application examining the files, both .js and .json.

## Netlify Dev

The newest deployment option on the block is the Netlify CLI, a.k.a. Netlify Dev. This encompasses two main deployment options, as well as script to create, build, and test functions. 

`netlify deploy` will deploy to a Netlify server; it requires a build step prior to deployment.

`netlify dev` creates a local server, along with a proxy to your lambda functions, and kicks off the application. It does not require a build step.

There is also a script to help you create your lambda functions: `netlify function:create`.  If you use this method, you will get a folder structure different from the one used by the previous deployment methods:

![](/media/screenshot-2019-11-05-at-4.11.21-pm.png "Folder structure generated by `netlify function:create`")

Each function has its own folder, along with a node_modules and package.json file (plus others not shown, such as .lock files). Similar to what would be in the .zip archives that zip-it-and-ship-it creates.

Now, if you do generate your lambdas this way, continuous deployment will break, as it correctly attempts to build the lambda code without some assistance on your part. For instance, you may have to put something like this in your build script:

```
"build": "npm-run-all build:*",
"build:app": "react-scripts build",
"build:functions": "yarn --cwd functions/func1 install",
"build:functions": "yarn --cwd functions/func2 install",
```

Which will install the dependencies needed by each lambda.

For my projects, I'll be using the Netlify Dev CLI going forward.

# The Example

Your homework assignment is to set up a Netlify account and a Firebase account. You will also need to grab a Firebase credentials JSON file and put it somewhere in your project (the example uses fake-creds.json, which is FAKE). You need to be able to authenticate using Netlify Identity, as well.

## About what this does

I'm a kind of a chess nut, so for this example I'll load in a partial chess openings book (in JSON) into the firestore database. In this somewhat contrived example, the book is actually stored with the lambda function, but its loading is triggered by the React client through a GraphQL mutation call. 

## Creating the lambda function

For the lambda function, I used apollo-server-lambda to serve up the GraphQL API to the Firestore database. To talks to Firestore, I'll use firebase-admin. I can get a start on generating this function using `netlify function:create`. It will ask me what template I want to use for the lambda function; the correct choice is in blue:

![](/media/screenshot-2019-11-05-at-4.39.37-pm.png)

In addition, I will add some utility functions, the firebase-admin dependency, and supporting GraphQL schema and resolvers.

**The lambda function**

```js
/* eslint-disable no-unused-vars */
const apolloLambda = require('apollo-server-lambda');
const admin = require('firebase-admin');
const typeDefs = require('./schema.gql');
const { fetchGames, addOpenings } = require('./resolvers');

const {
  ApolloServer,
} = apolloLambda;

const credential = require('./fake-creds.json');


admin.initializeApp({
  credential: admin.credential.cert(credential),
});


const resolvers = {
  Query: {
    allGames: (root, args, context) => [], //TBD
  },
  Mutation: {
    addOpenings: async (root, args, context) => addOpenings(root, args, { ...context, admin }),
  },
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

exports.handler = server.createHandler(
  {
    cors: {
      origin: '*',
      credentials: true,
    },
  },
);
```

**The Schema**

```
const typeDefs = `

type Mutation {
  addOpenings(start: Int!, end: Int!) : Int! 
}
`

module.exports = typeDefs;
```

**The resolver**

```
const openings = require('./scid.js');


const addOpenings = async (_, { start, end }, { admin }) => {
  const db = admin.firestore();
  const batch = db.batch();
  const fens = db.collection('chess/openings/fen');
  const data = openings.slice(start, end);

  data.forEach((opening) => {
    const id = opening.fen.replace(/\//g, '$');
    const doc = fens.doc(id);
    batch.set(doc, opening);
  });

  await batch.commit();

  return data.length;
};

module.exports = {  addOpenings };
```

**The opening book**
```
/* eslint-disable comma-dangle */
module.exports = [
  {
    SCID: 'A00b',
    desc: '"Barnes Opening"',
    fen: 'rnbqkbnr/pppppppp/8/8/8/5P2/PPPPP1PP/RNBQKBNR b KQkq - 0 1'
  },
  {
    SCID: 'A00b',
    desc: '"Fried fox"',
    fen: 'rnbqkbnr/pppp1ppp/8/4p3/8/5P2/PPPPPKPP/RNBQ1BNR b kq - 1 2'
  },
  {
    SCID: 'A00c',
    desc: '"Kadas Opening"',
    fen: 'rnbqkbnr/pppppppp/8/8/7P/8/PPPPPPP1/RNBQKBNR b KQkq h3 0 1'
  },
  {
    SCID: 'A00d',
    desc: '"Clemenz Opening"',
    fen: 'rnbqkbnr/pppppppp/8/8/8/7P/PPPPPPP1/RNBQKBNR b KQkq - 0 1'
  },
  {
    SCID: 'A00e',
    desc: '"Ware Opening"',
    fen: 'rnbqkbnr/pppppppp/8/8/P7/8/1PPPPPPP/RNBQKBNR b KQkq a3 0 1'
  },
  {
    SCID: 'A00f',
    desc: '"Anderssen Opening"',
    fen: 'rnbqkbnr/pppppppp/8/8/8/P7/1PPPPPPP/RNBQKBNR b KQkq - 0 1'
  },
  {
    SCID: 'A00f',
    desc: '"Creepy Crawly Opening (Basman)"',
    fen: 'rnbqkbnr/ppp2ppp/8/3pp3/8/P6P/1PPPPPP1/RNBQKBNR w KQkq d6 0 3'
  },
  {
    SCID: 'A00g',
    desc: '"Amar/Paris Opening"',
    fen: 'rnbqkbnr/pppppppp/8/8/8/7N/PPPPPPPP/RNBQKB1R b KQkq - 1 1'
  },
];

```


****


## Creating the client

Naturally I want to use apollo-client (in for a dime, in for a dollar as the saying goes). The easiest way I've found is to use create-react-app, and \[apollo-boost] to get a skeletal client up and running quickly.  Once this is done, I create a React component to trigger a call to my lambda, using the GraphQL API it provides.

\[code snippet]

And the response I'll show in a window alert box:

\[image]

## Added bonus!

Since I used apollo-server-lambda as a basis for the Netlify Function, I can go directly to the service endpoint via URL and it will bring up GraphQL Playground:

\[image]

Here I can test queries and mutations prior to embedding them in my React client code.

**Also**, when using \`netlify dev\` I have a hot server courtesy of create-react-app, so I can see result of code changes in "real" time. 

# Deployment

As I mentioned, there are several ways of deploying, but my preference is:

1. netlify dev for work-in-progress (local server)
2. yarn build to build the project; then netlify deploy to deploy it to a temporary netlify server
3. finally, netlify deploy --prod to deploy to my production server

- - -

That's it!  Here's a link to source.
